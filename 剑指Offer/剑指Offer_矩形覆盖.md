# 剑指Offer: 矩形覆盖

### 题目描述

我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

#### 样例

```cpp
比如n=3时，2*3的矩形块有3种覆盖方法：
```

----------

### 算法 递归+滚动变量

  我们将上面模型映射到一维，即是我们有一条长度为n的线段，现在要么放置长度为1，要么放置长度为2的线段，请将该线段填满。 这就转化成了走台阶的题目，一个n级阶梯，每次要么走一级要么两级，请问有多少种方法。 <font color=red size = 5> (走台阶的思路：当前台阶的跳法总数 = 当前台阶后退一阶的台阶的跳法总数+当前台阶后退二阶的台阶的跳法总数) </font>

  综上分析，可知，

n <= 0 时， f(n) = 0; 
n = 1时， f(n) = 1; 
n = 2时， f(n) = 2; 
n > 2时，f(n) = f(n - 1) + f(n - 2); 
标准的斐波那契数列，故可用斐波那契数列解

#### 时空分析

时间复杂度分析:  ***O(n)***

空间复杂度分析:  ***O(1)***

#### C++ 代码

```cpp
class Solution {
public:
    int rectCover(int number) {
        if (number <= 0)
            return 0;
        else if (number == 1)
            return 1;
        else if (number == 2)
            return 2;
        
        int a = 1, b = 2, z = 0;
        for (int i = 3; i <= number; i++)
        {
            z = a + b;
            a = b;
            b = z;
        }
        
        return z;
    }
};
```

斐波那契数列其他解法详见，[剑指Offer: 斐波那契数列]( https://blog.csdn.net/Erice_s/article/details/104623285 )

